\documentclass[a4paper,11pt]{article}

\usepackage{underscore}
\usepackage{listings}
\lstloadlanguages{Python}
\lstset{
language         = Python,
basicstyle       = \ttfamily\footnotesize,
keepspaces       = true,
showstringspaces = false
}

\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

\title{A Guide to Python's Magic Methods}
\author{Rafe Kettler}
\date{2011}
\maketitle

\section{Introduction}

This guide is the culmination of a few months' worth of blog posts. The subject is \textbf{magic methods}.

What are magic methods? They're everything in object-oriented Python. They're special methods that you can define to add "magic" to your classes. They're always surrounded by double underscores (e.g. \code{__init__} or \code{__lt__}). They're also not as well documented as they need to be. All of the magic methods for Python appear in the same section in the Python docs, but they're scattered about and only loosely organized. There's hardly an example to be found in that section (and that may very well be by design, since they're all detailed in the \emph{language reference}, along with boring syntax descriptions, etc.).

So, to fix what I perceived as a flaw in Python's documentation, I set out to provide some more plain-English, example-driven documentation for Python's magic methods. I started out with weekly blog posts, and now that I've finished with those, I've put together this guide.

I hope you enjoy it. Use it as a tutorial, a refresher, or a reference; it's just intended to be a user-friendly guide to Python's magic methods.

\section{Construction and Initialization}

Everyone knows the most basic magic method, \code{__init__}. It's the way that we can define the initialization behavior of an object. However, when I call \code{x = SomeClass()}, \code{__init__} is not the first thing to get called. Actually, it's a method called \code{__new__}, which actually creates the instance, then passes any arguments at creation on to the initializer. At the other end of the object's lifespan, there's \code{__del__}. Let's take a closer look at these 3 magic methods:

\begin{description}

\item[\code{__new__(cls, [...)}]
\code{__new__} is the first method to get called in an object's instantiation. It takes the class, then any other arguments that it will pass along to \code{__init__}. \code{__new__} is used fairly rarely, but it does have its purposes, particularly when subclassing an immutable type like a tuple or a string. I don't want to go in to too much detail on \code{__new__} because it's not too useful, but it is covered in great detail in the Python docs.

\item[\code{__init__(self, [...)}]
The initializer for the class. It gets passed whatever the primary constructor was called with (so, for example, if we called \code{x = SomeClass(10, 'foo')}, \code{__init__} would get passed \code{10} and \code{'foo'} as arguments. \code{__init__} is almost universally used in Python class definitions.

\item[\code{__del__(self)}]
If \code{__new__} and \code{__init__} formed the constructor of the object, \code{__del__} is the destructor. It doesn't implement behavior for the statement \code{del x} (so that code would not translate to \code{x.__del__()}). Rather, it defines behavior for when an object is garbage collected. It can be quite useful for objects that might require extra cleanup upon deletion, like sockets or file objects. Be careful, however, as there is no guarantee that \code{__del__} will be executed if the object is still alive when the interpreter exits, so \code{__del__} can't serve as a replacement for good coding practices (like always closing a connection when you're done with it.

\end{description}

Putting it all together, here's an example of \code{__init__} and \code{__del__} in action:

\lstinputlisting[language=Python]{listings/fileobject.py}

\section{Making Operators Work on Custom Classes}

One of the biggest advantages of using Python's magic methods is that they provide a simple way to make objects behave like built-in types. That means you can avoid ugly, counter-intuitive, and nonstandard ways of performing basic operators. In some languages, it's common to do something like this:

\begin{lstlisting}
if instance.equals(other_instance):
    # do something
\end{lstlisting}

You could certainly do this in Python, too, but this adds confusion and is unnecessarily verbose. Different libraries might use different names for the same operations, making the client do way more work than necessary. With the power of magic methods, however, we can define one method (\code{__eq__}, in this case), and say what we \emph{mean} instead:

\begin{lstlisting}
if instance == other_instance:
    #do something
\end{lstlisting}

That's part of the power of magic methods. The vast majority of them allow us to define meaning for operators so that we can use them on our own classes just like they were built in types.

\subsection{Comparison magic methods}

Python has a whole slew of magic methods designed to implement intuitive comparisons between objects using operators, not awkward method calls. They also provide a way to override the default Python behavior for comparisons of objects (by reference). Here's the list of those methods and what they do:

\begin{description}

\item[\code{__cmp__(self, other)}]
:    \code{__cmp__} is the most basic of the comparison magic methods. It actually implements behavior for all of the comparison operators (<, ==, !=, etc.), but it might not do it the way you want (for example, if whether one instance was equal to another were determined by one criterion and and whether an instance is greater than another were determined by something else). \code{__cmp__} should return a negative integer if \code{self < other}, zero if \code{self == other}, and positive if \code{self > other}. It's usually best to define each comparison you need rather than define them all at once, but \code{__cmp__} can be a good way to save repetition and improve clarity when you need all comparisons implemented with similar criteria.

\item[\code{__eq__(self, other)}]
Defines behavior for the equality operator, \code{==}.
\item[\code{__ne__(self, other)}]
Defines behavior for the inequality operator, \code{!=}.
\item[\code{__lt__(self, other)}]
Defines behavior for the less-than operator, \code{<}.
\item[\code{__gt__(self, other)}]
Defines behavior for the greater-than operator, \code{>}.
\item[\code{__le__(self, other)}]
Defines behavior for the less-than-or-equal-to operator, \code{<=}.
\item[\code{__ge__(self, other)}]
Defines behavior for the greater-than-or-equal-to operator, \code{>=}.

\end{description}

For an example, consider a class to model a word. We might want to compare words lexicographically (by the alphabet), which is the default comparison behavior for strings, but we also might want to do it based on some other criterion, like length or number of syllables. In this example, we'll compare by length. Here's an implementation:

\lstinputlisting{listings/word.py}

Now, we can create two \code{Word}s (by using \code{Word('foo')} and \code{Word('bar')}) and compare them based on length. Note, however, that we didn't define \code{__eq__} and \code{__ne__}. This is because this would lead to some weird behavior (notably that \code{Word('foo') == Word('bar')} would evaluate to true). It wouldn't make sense to test for equality based on length, so we fall back on \code{str}'s implementation of equality.

Now would be a good time to note that you don't have to define every comparison magic method to get rich comparisons. The standard library has kindly provided us with a class decorator in the module \code{functools} that will define all rich comparison methods if you only define \code{__eq__} and one other (e.g. \code{__gt__}, \code{__lt__}, etc.) This feature is only available in Python 2.7, but when you get a chance it saves a great deal of time and effort. You can use it by placing \code{@total_ordering} above your class definition.

\subsection{Numeric Magic Methods}

Just like you can create ways for instances of your class to be compared with comparison operators, you can define behavior for numeric operators. Buckle your seat belts, folks, there's a lot of these. For organization's sake, I've split the numeric magic methods into 5 categories: unary operators, normal arithmetic operators, reflected arithmetic operators (more on this later), augmented assignment, and type conversions.

\subsubsection{Unary operators and functions}

Unary operators and functions only have one operand, e.g. negation, absolute value, etc.

\begin{description}

\item[`__pos__(self)`]
Implements behavior for unary positive (e.g. `+some_object`)
\item[`__neg__(self)`]
Implements behavior for negation (e.g. `-some_object`)
\item[`__abs__(self)`]
Implements behavior for the built in `abs()` function.
\item[`__invert__(self)`]
Implements behavior for inversion using the `\char126` operator.

\end{description}

\subsection{Normal arithmetic operators}

Now, we cover the typical binary operators (and a function or two): +, -, * and the like. These are, for the most part, pretty self-explanatory.

\begin{description}

\item[\code{__add__(self, other)}]
Implements addition.
\item[\code{__sub__(self, other)}]
Implements subtraction.
\item[\code{__mul__(self, other)}]
Implements multiplication.
\item[\code{__floordiv__(self, other)}]
Implements integer division using the \code{//} operator.
\item[\code{__div__(self, other)}]
Implements division using the \code{/} operator.
\item[\code{__truediv__(self, other)}]
Implements _true_ division. Note that this only works when \code{from __future__ import division} is in effect.
\item[\code{__mod_(self, other)}]
Implements modulo using the \code{\%} operator.
\item[\code{__divmod__(self, other)}]
Implements behavior for long division using the \code{divmod()} built in function.
\item[\code{__pow__}]
Implements behavior for exponents using the \code{**} operator.
\item[\code{__lshift__(self, other)}]
Implements left bitwise shift using the \code{<<} operator.
\item[\code{__rshift__(self, other)}]
Implements right bitwise shift using the \code{>>} operator.
\item[\code{__and__(self, other)}]
Implements bitwise and using the \code{\&} operator.
\item[\code{__or__(self, other)}]
Implements bitwise or using the \code{|} operator.
\item[\code{__xor__(self, other)}]
Implements bitwise xor using the \code{\char94} operator.

\end{description}

\subsubsection{Reflected arithmetic operators}

You know how I said I would get to reflected arithmetic in a bit? Some of you might think it's some big, scary, foreign concept. It's actually quite simple. Here's an example:

    :::python
    some_object + other

That was "normal" addition. The reflected equivalent is the same thing, except with the operands switched around:

\begin{lstlisting}
other + some_object
\end{lstlisting}

So, all of these magic methods do the same thing as their normal equivalents, except the perform the operation with other as the first operand and self as the second, rather than the other way around. In most cases, the result of a reflected operation is the same as its normal equivalent, so you may just end up defining \code{__radd__} as calling \code{__add__} and so on. Without further ado:

\begin{description}

\item[\code{__radd__(self, other)}]
Implements reflected addition.
\item[\code{__rsub__(self, other)}]
Implements reflected subtraction.
\item[\code{__rmul__(self, other)}]
Implements reflected multiplication.
\item[\code{__rfloordiv__(self, other)}]
Implements reflected integer division using the \code{//} operator.
\item[\code{__rdiv__(self, other)}]
Implements reflected division using the \code{/} operator.
\item[\code{__rtruediv__(self, other)}]
Implements reflected _true_ division. Note that this only works when \code{from __future__ import division} is in effect.
\item[\code{__rmod_(self, other)}]
Implements reflected modulo using the \code{\%} operator.
\item[\code{__rdivmod__(self, other)}]
Implements behavior for long division using the \code{divmod()} built in function, when \code{divmod(other, self)} is called.
\item[\code{__rpow__}]
Implements behavior for reflected exponents using the \code{**} operator.
\item[\code{__rlshift__(self, other)}]
Implements reflected left bitwise shift using the \code{<<} operator.
\item[\code{__rrshift__(self, other)}]
Implements reflected right bitwise shift using the \code{>>} operator.
\item[\code{__rand__(self, other)}]
Implements reflected bitwise and using the \code{\&} operator.
\item[\code{__ror__(self, other)}]
Implements reflected bitwise or using the \code{|} operator.
\item[\code{__rxor__(self, other)}]
Implements reflected bitwise xor using the \code{\char94} operator.

\end{description}

\subsubsection{Augmented assignment}

Python also has a wide variety of magic methods to allow custom behavior to be defined for augmented assignment. You're probably already familiar with augmented assignment, it combines ``normal'' operators with assignment. If you still don't know what I'm talking about, here's an example:

\begin{lstlisting}
x = 5
x += 1 # in other words x = x + 1
\end{lstlisting}

Each of these methods does not return a value, because assignment in Python does not return any value. Instead, they just alter the state of the class. Here's the list:

\begin{description}

\item[\code{__iadd__(self, other)}]
Implements addition with assignment.
\item[\code{__isub__(self, other)}]
Implements subtraction with assignment.
\item[\code{__imul__(self, other)}]
Implements multiplication with assignment.
\item[\code{__ifloordiv__(self, other)}]
Implements integer division with assignment using the \code{//=} operator.
\item[\code{__idiv__(self, other)}]
Implements division with assignment using the \code{/=} operator.
\item[\code{__itruediv__(self, other)}]
Implements _true_ division with assignment. Note that this only works when \code{from __future__ import division} is in effect.
\item[\code{__imod_(self, other)}]
Implements modulo with assignment using the \code{\%=} operator.
\item[\code{__ipow__}]
Implements behavior for exponents with assignment using the \code{**=} operator.
\item[\code{__ilshift__(self, other)}]
Implements left bitwise shift with assignment using the \code{<<=} operator.
\item[\code{__irshift__(self, other)}]
Implements right bitwise shift with assignment using the \code{>>=} operator.
\item[\code{__iand__(self, other)}]
Implements bitwise and with assignment using the \code{\&=} operator.
\item[\code{__ior__(self, other)}]
Implements bitwise or with assignment using the \code{|=} operator.
\item[\code{__ixor__(self, other)}]
Implements bitwise xor with assignment using the \code{\char94=} operator.

\end{description}

\subsubsection{Type conversion magic methods}

Python also has an array of magic methods designed to implement behavior for built in type conversion functions like \code{float()}. Here they are:

\begin{description}

\item[\code{__int__(self)}]
Implements type conversion to int.
\item[\code{__long__(self)}]
Implements type conversion to long.
\item[\code{__float__(self)}]
Implements type conversion to float.
\item[\code{__complex__(self)}]
Implements type conversion to complex.
\item[\code{__oct__(self)}]
Implements type conversion to octal.
\item[\code{__hex__(self)}]
Implements type conversion to hexadecimal.
\item[\code{__index__(self)}]
Implements type conversion to an int when the object is used in a slice expression. If you define a custom numeric type that might be used in slicing, you should define \code{__index__}.
\item[\code{__trunc__(self)}]
Called when \code{math.trunc(self)} is called. \code{__trunc__} should return the value of \code{self} truncated to an integral type (usually a long).
\item[\code{__coerce__(self, other)}]
Method to implement mixed mode arithmetic. \code{__coerce__} should return \code{None} if type conversion is impossible. Otherwise, it should return a pair (2-tuple) of \code{self} and \code{other}, manipulated to have the same type.

\end{description}

\end{document}
